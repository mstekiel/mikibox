

<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mikibox.crysfipy.observables &#8212; mikibox 0.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bizstyle.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">mikibox 0.2.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mikibox.crysfipy.observables</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for mikibox.crysfipy.observables</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">constants</span> <span class="k">as</span> <span class="n">C</span>
<span class="kn">from</span> <span class="nn">.cefmatrices</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.cefion</span> <span class="kn">import</span> <span class="n">CEFion</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    

<div class="viewcode-block" id="boltzman_population"><a class="viewcode-back" href="../../../source/crysfipy.html#mikibox.crysfipy.observables.boltzman_population">[docs]</a><span class="k">def</span> <span class="nf">boltzman_population</span><span class="p">(</span><span class="n">energies</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculate the population of energy levels at given temperature based on the Boltzmann statistic.</span>
<span class="sd">    :math:`p_i = \frac{1}{Z} e^{-E_i/k_B T}`</span>
<span class="sd">    :math:`Z = \sum_i e^{-Ei/k_BT}`</span>
<span class="sd">    One important distinction, is that this function works with eigenvalues (energies) from the whole Hilbert space,</span>
<span class="sd">    as it needs to evaluate :math:`Z` on its own. This works well for the total angular momentum Hilbert space, and does care about degeneracies.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        energies: List of energy levels in meV units</span>
<span class="sd">        temperature: Temperature at which to evaluate the statistic</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of occupation probabilities for each energy level.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">meV2K</span><span class="o">/</span><span class="n">temperature</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">/</span> <span class="n">Z</span></div>

<span class="k">def</span> <span class="nf">_rawneutronint</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">J2_perp</span><span class="p">,</span> <span class="n">gJ</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns transition intensities in barn.</span>
<span class="sd">    </span>
<span class="sd">    TODO I think the Debye-Waller factor needs to be incorporated here for proper inter-Temperature comparisons</span>

<span class="sd">    Args:</span>
<span class="sd">        E (2D array of floats): matrix of energy changes corresponding to transitions in meV</span>
<span class="sd">        J2_perp (2D array of floats): matrix of squared J</span>
<span class="sd">        gJ (float): Land√© factor</span>
<span class="sd">        T (float): temperature in **K**</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r02</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">R0</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">R0</span>  <span class="o">*</span><span class="mf">1e28</span> <span class="c1"># to have value in barn</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">r02</span> <span class="o">*</span> <span class="n">gJ</span> <span class="o">*</span> <span class="n">gJ</span>
    
    <span class="c1"># Calculate the occupancy of the levels at given temperature</span>
    <span class="n">prst</span> <span class="o">=</span> <span class="n">boltzman_population</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">T</span><span class="p">)</span>
    
    <span class="c1"># Multiply the matrix elements by uprobability of occupying certain level</span>
    <span class="n">trans_int</span> <span class="o">=</span> <span class="n">J2_perp</span> <span class="o">*</span> <span class="n">prst</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span>  <span class="c1">#transition intensities in barn</span>
    
    <span class="k">return</span> <span class="n">trans_int</span>

<div class="viewcode-block" id="neutronint"><a class="viewcode-back" href="../../../source/crysfipy.html#mikibox.crysfipy.observables.neutronint">[docs]</a><span class="k">def</span> <span class="nf">neutronint</span><span class="p">(</span><span class="n">cefion</span><span class="p">:</span> <span class="n">CEFion</span><span class="p">,</span> <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="nb">tuple</span> <span class="p">,</span> <span class="n">scheme</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Ei</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1e+6</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns matrix of energies and inelastic neutron scattering spectral weights for all possible transitions at given temperature. The spectral weight is calculated by equation from Enderle book following Stephane Raymond article.</span>
<span class="sd">    </span>
<span class="sd">    | :math:`S(\vec{Q},\omega) = N (\gamma r_0)^2 f^2_m(Q) e^{-2W(Q)} \sum_{if} \frac{k_f}{k_i} p_i |&lt;\lambda_f|J_\perp|\lambda_i&gt;|^2 \delta(E_i - E_f - \hbar \omega)`</span>
<span class="sd">    | :math:`N (\gamma r_0)^2` : ignored, acts as units.</span>
<span class="sd">    | :math:`f^2_m(Q)` : magnetic form factor, taken from internal tables in ``mikibox.crysfipy.Ion`` class.</span>
<span class="sd">    | :math:`e^{-2W(Q)}` : :math:`W(Q)` is the Debye-Waller factor. It is quite problematic, is set to 1 at the moment.</span>
<span class="sd">    | :math:`\frac{k_f}{k_i}` : scaling factor calculated from energy, which is used more widely :math:`\frac{k_f}{k_i} = \sqrt{1-\frac{\Delta E}{E_i}}`. there is a minus under the square root, because positive energy transfer corresponds to neutron energy loss.</span>
<span class="sd">    | :math:`p_i` : Boltzmann population factor.</span>
<span class="sd">    | :math:`|&lt;\lambda_f|J_\perp|\lambda_i&gt;|^2` : matrix elements, exact description depends on ``Q``, see below.</span>

<span class="sd">    </span>
<span class="sd">    The intensities are evaluated based on the :math:`|&lt;\lambda_f|J_\perp|\lambda_i&gt;|^2` matrix elements, which form a matrix :math:`|J_\perp|^2`.</span>
<span class="sd">    Two main cases are implemented and encoded in the :data:`Q` parameter.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        cefion: :class:`CEFion` Rare-earth ion in the crystal field</span>
<span class="sd">        tempreature:  Temperature in *K*</span>
<span class="sd">        Q :  List of Q vectors used to evaluate the spectral weight</span>
<span class="sd">        </span>
<span class="sd">        scheme : &#39;powder&#39;, &#39;single-crystal&#39;:</span>
<span class="sd">            Scheme according to which :math:`|J_\perp|^2` is calculated.</span>
<span class="sd">            </span>
<span class="sd">            * powder :  :math:`|&lt;\lambda_f|J_\perp|\lambda_i&gt;|^2 = 2/3\sum_\alpha |&lt;\lambda_f|J_\alpha|\lambda_i&gt;|^2` (default).</span>
<span class="sd">            * (single-crystal : :math:`|&lt;\lambda_f|J_\perp|\lambda_i&gt;|^2 = \sum_\alpha (1-\frac{Q_\alpha}{Q})|&lt;\lambda_f|J_\alpha|\lambda_i&gt;|^2`. Q is a vector representing a direction in the reciprocal space in respect to which a perpendicular projection of :math:`J` will be calculated.</span>

<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        energies : ndarray</span>
<span class="sd">            Array containing energies of the transitions</span>
<span class="sd">        intensities : ndarray</span>
<span class="sd">            Array containing intensities of the transitions</span>
<span class="sd">            </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError </span>
<span class="sd">            When an invalid ``Q`` parameter is chosen, or the dimension of the ``Q`` vector is not 3. </span>
<span class="sd">        RuntimeWarning</span>
<span class="sd">            When Q=[0,0,0], where the spectral weight is ill defined.        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># The way it is calculated is that the factor within the sum is calculated as a matrix, which is flattened at the end. Energy degeneracies are not taken into account, as it is easier to handle.</span>
    
    <span class="c1"># Magnetic form factor</span>
    <span class="n">f2m</span> <span class="o">=</span> <span class="n">cefion</span><span class="o">.</span><span class="n">ion</span><span class="o">.</span><span class="n">mff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="c1"># Debye-Waller factor</span>
    <span class="n">eDW</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Tricky way to create a 2D array of energies associated with transitions between levels</span>
    <span class="n">jumps</span> <span class="o">=</span> <span class="n">cefion</span><span class="o">.</span><span class="n">energies</span> <span class="o">-</span> <span class="n">cefion</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>    
    
    <span class="c1"># Calculate the |&lt;\Gamma_f|J_\perp|\Gamma_i&gt;|^2 matrix</span>
    <span class="k">if</span> <span class="n">scheme</span><span class="o">==</span><span class="s1">&#39;single-crystal&#39;</span><span class="p">:</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Dimension of the``Q`` vector is not 3&#39;</span><span class="p">)</span>
            
        <span class="c1"># First implementation does not seem to work well</span>
        <span class="c1"># Qperp_projectCEFion = ms.perp_matrix(Q)</span>
        <span class="c1"># J_perp = np.einsum(&#39;ij,jkl&#39;,Qperp_projectCEFion, cefion.J)</span>
        <span class="c1"># J2_perp = np.einsum(&#39;ijk-&gt;jk&#39;, np.square(np.abs(J_perp)))</span>
        
        <span class="n">J2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">J</span><span class="p">))</span>
        <span class="n">projection</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">Q</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="n">J2_perp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ijk&#39;</span><span class="p">,</span><span class="n">projection</span><span class="p">,</span> <span class="n">J2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">scheme</span><span class="o">==</span><span class="s1">&#39;powder&#39;</span><span class="p">:</span>
        <span class="n">J2_perp</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk-&gt;jk&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">J</span><span class="p">)))</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid ``Q`` parameter&#39;</span><span class="p">)</span>
        
        
    <span class="c1"># kf/ki factor, which is actually a matrix</span>
    <span class="n">kfki</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">jumps</span><span class="o">/</span><span class="n">Ei</span><span class="p">)</span>
    
    <span class="c1"># Occupation</span>
    <span class="n">transition_probs</span> <span class="o">=</span> <span class="n">boltzman_population</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">energies</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        
    <span class="c1"># Multiply the factors, vectors and matrices properly to get spectral weight.</span>
    <span class="n">Sqw</span> <span class="o">=</span> <span class="n">f2m</span> <span class="o">*</span> <span class="n">eDW</span> <span class="o">*</span> <span class="n">kfki</span> <span class="o">*</span> <span class="n">J2_perp</span> <span class="o">*</span> <span class="n">transition_probs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    
    <span class="n">Denergies</span> <span class="o">=</span> <span class="n">jumps</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">sorting</span> <span class="o">=</span> <span class="n">Denergies</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">Denergies</span><span class="p">[</span><span class="n">sorting</span><span class="p">],</span> <span class="n">Sqw</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">sorting</span><span class="p">])</span></div>

<div class="viewcode-block" id="magnetization"><a class="viewcode-back" href="../../../source/crysfipy.html#mikibox.crysfipy.observables.magnetization">[docs]</a><span class="k">def</span> <span class="nf">magnetization</span><span class="p">(</span><span class="n">cefion</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Hfield</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Calculate the magnetization of the single ion in the crystal field. Returned value is in :math:`\mu_B` units.</span>
<span class="sd">    :math:`M_\alpha = g_J \sum_n p_n |&lt;\lambda_n | \hat{J}_\alpha | \lambda_n&gt;|`</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">cefion_inH</span> <span class="o">=</span> <span class="n">CEFion</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">ion</span><span class="p">,</span> <span class="n">Hfield</span><span class="p">,</span> <span class="n">cefion</span><span class="o">.</span><span class="n">cfp</span><span class="p">,</span> <span class="n">diagonalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># The diagonalized Hamiltonians&#39; operators are already transformed into the sorted eigenvector base</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">boltzman_population</span><span class="p">(</span><span class="n">cefion_inH</span><span class="o">.</span><span class="n">energies</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">cefion_inH</span><span class="o">.</span><span class="n">ion</span><span class="o">.</span><span class="n">gJ</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijj,j&#39;</span><span class="p">,</span><span class="n">cefion_inH</span><span class="o">.</span><span class="n">J</span><span class="p">,</span><span class="n">p</span><span class="p">)</span> <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">M</span></div>


<span class="k">def</span> <span class="nf">_rawsusceptibility</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="n">moment</span><span class="p">,</span> <span class="n">H_direction</span><span class="p">,</span> <span class="n">H_size</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns susceptibility calculated for energy levels at given temperature&quot;&quot;&quot;</span>

    <span class="n">prst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="o">/</span><span class="n">T</span><span class="p">)</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">prst</span><span class="p">);</span>                                    <span class="c1"># canonical partition function </span>
    <span class="n">prst</span> <span class="o">=</span> <span class="n">prst</span> <span class="o">/</span> <span class="n">Z</span><span class="p">;</span>
    <span class="n">overal_moment</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">prst</span><span class="p">,</span> <span class="n">moment</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">overal_moment</span><span class="p">,</span> <span class="n">H_direction</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="n">H_size</span>

<div class="viewcode-block" id="susceptibility"><a class="viewcode-back" href="../../../source/crysfipy.html#mikibox.crysfipy.observables.susceptibility">[docs]</a><span class="k">def</span> <span class="nf">susceptibility</span><span class="p">(</span><span class="n">cefion</span><span class="p">:</span> <span class="n">CEFion</span><span class="p">,</span> <span class="n">temperatures</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">Hfield_direction</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">,</span><span class="nb">float</span><span class="p">],</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;perturbation&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the magnetic susceptibility at given temperature.</span>
<span class="sd">    </span>
<span class="sd">    The susceptibility is calculated from the perturbation of the Hamiltonian.</span>
<span class="sd">    </span>
<span class="sd">    | :math:`\chi_{CEF} = (g_J \mu_B)^2 \left[ \sum_{n,m \neq n}  p_n \frac{1-exp(-\Delta_{m,n}/k_B T)}{\Delta_{m,n}} |&lt;\lambda_m|J|\lambda_n&gt;|^2  +  \frac{1}{k_B T} \sum_{n} p_n |&lt;\lambda_n|J|\lambda_n&gt;|^2 \right]`</span>
<span class="sd">    | :math:`g_J \mu_B` : Lande factor, Bohr magneton.</span>
<span class="sd">    | :math:`p_n` : Ptobabitlity of occupying the energy level :math:`\lambda_n` at given temperature.</span>
<span class="sd">    | :math:`\Delta_{m,n}` : Energy of transition between the :math:`\lambda_n` and :math:`\lambda_m` levels.</span>
<span class="sd">    | :math:`&lt;\lambda_m|J|\lambda_n&gt;` : J matrix elements.</span>

<span class="sd">    ALL BELOW MADE A CRASH FOR ANOTER SYSTEM</span>
<span class="sd">    In calculations a dangerous trick is used. The :math:`\frac{1-exp(-\Delta_{m,n}/k_B T)}{\Delta_{m,n}}` </span>
<span class="sd">    factor is computed as a matrix, so naturally it will be divergent on the diagonal, since :math:`\Delta_{m,n}=0` there. </span>
<span class="sd">    This raises a RuntimeWarning which is ignored , and the diagonal is replaced with the :math:`1/k_B T` values, and the two summations are bundled together. </span>
<span class="sd">    This feels dirty, but works so far, even for spin-half systems, which have degenerated energy levels.</span>
<span class="sd">    Maybe because the transitions between degenerated levels are not exactly 0 in the calculations (1e-15 rather).</span>

<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        cefion : :class:`crysfipy.CEFion`</span>
<span class="sd">            Rare-earth ion in crystal field\</span>
<span class="sd">        temperatures : ndarray</span>
<span class="sd">            Array ocntaining temperatures at which to compute the susceptibility.</span>
<span class="sd">        Hfield_direction:</span>
<span class="sd">            Direction of the applied magnetic field. Value can be arbitrary, it is normalized in the code.</span>
<span class="sd">        method: optional, &#39;perturbation&#39;, &#39;magnetization&#39;</span>
<span class="sd">            Method by which to calculate susceptibility. Old implementation </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        List of susceptibility values calculated at given temperatures. In the units of :math:`\mu_B^2`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    


    <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;magnetization&#39;</span><span class="p">:</span>
        <span class="n">susceptibility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temperatures</span><span class="p">))</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-8</span>
        
        <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="n">temperature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temperatures</span><span class="p">):</span>
            <span class="n">Hfield</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Hfield_direction</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Hfield_direction</span><span class="p">)</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">magnetization</span><span class="p">(</span><span class="n">cefion</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">Hfield</span><span class="p">)</span>
            <span class="n">susceptibility</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">/</span><span class="n">eps</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s1">&#39;perturbation&#39;</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        There is some problems here that need to be solved.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">susceptibility</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temperatures</span><span class="p">))</span>
        <span class="c1">#susceptibility.fill(np.nan)</span>

        <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="n">temperature</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temperatures</span><span class="p">):</span>
            <span class="c1"># Tricky way to create a 2D array of energies associated with transitions between levels</span>
            <span class="n">jumps</span> <span class="o">=</span> <span class="n">cefion</span><span class="o">.</span><span class="n">energies</span> <span class="o">-</span> <span class="n">cefion</span><span class="o">.</span><span class="n">energies</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># 1. jumps can be zero</span>
            <span class="c1"># 2. argument in exp can be relatively big 2800, and reise overflow. Might by onsly special versions of numpy will have problem with that.</span>
            <span class="c1"># Probably some mathematics can be applied here to shorten these formulas and avoid big numbers</span>
            <span class="n">Tmx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">(</span><span class="o">-</span><span class="n">jumps</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">meV2K</span><span class="o">/</span><span class="n">temperature</span><span class="p">)</span><span class="o">/</span><span class="n">jumps</span>

            <span class="c1"># if the states are degenerated the diagonal is not enough</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">Tmx</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="n">C</span><span class="o">.</span><span class="n">meV2K</span><span class="o">/</span><span class="n">temperature</span><span class="p">)</span> 
            
            <span class="n">transition_probs</span> <span class="o">=</span> <span class="n">boltzman_population</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">energies</span><span class="p">,</span> <span class="n">temperature</span><span class="p">)</span>
            <span class="n">Tmx</span> <span class="o">=</span> <span class="n">Tmx</span> <span class="o">*</span> <span class="n">transition_probs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>


            
            <span class="n">J2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">J</span><span class="p">))</span>
            <span class="n">J2_directed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;i,ijk&#39;</span><span class="p">,</span><span class="n">Hfield_direction</span><span class="p">,</span> <span class="n">J2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Hfield_direction</span><span class="p">)</span>
            
            <span class="n">susceptibility</span><span class="p">[</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cefion</span><span class="o">.</span><span class="n">ion</span><span class="o">.</span><span class="n">gJ</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Tmx</span> <span class="o">*</span> <span class="n">J2_directed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown method to calculate magnetization.&#39;</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">susceptibility</span></div>
        
        
<div class="viewcode-block" id="thermodynamics"><a class="viewcode-back" href="../../../source/crysfipy.html#mikibox.crysfipy.observables.thermodynamics">[docs]</a><span class="k">def</span> <span class="nf">thermodynamics</span><span class="p">(</span><span class="n">cefion</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the fundamental thermodynamic values as a function of temperature.</span>
<span class="sd">    </span>
<span class="sd">    These functions are calculated alltogether taking advantage of the fact that thermodynamics can be determined from the partition function :math:`Z`, upon differentiation on :math:`\beta`, where :math:`\beta = \frac{1}{k_B T}`.</span>
<span class="sd">    </span>
<span class="sd">    | Partition function: :math:`Z = \sum_n e^{-\beta E_n}`</span>
<span class="sd">    | Average energy: :math:`\langle E \rangle = - \frac{\partial Z}{\partial \beta}`</span>
<span class="sd">    | Entropy: :math:`S = k_B ( \ln Z - \beta \frac{\partial Z}{\partial \beta} )`</span>
<span class="sd">    | Heat capacity: :math:`C_V = k_B \beta^2 \frac{\partial^2 Z}{\partial \beta^2}`</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        cefion : :obj:`crysfipy.CEFion`</span>
<span class="sd">            Rare-earth ion in crystal field</span>
<span class="sd">        T : ndarray</span>
<span class="sd">            Temperature</span>

<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        Z, E, S CV : The partition function, average energy (internal energy), entropy and heat capacity, respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">meV2K</span><span class="o">/</span><span class="n">T</span>
    
    <span class="k">for</span> <span class="n">En</span> <span class="ow">in</span> <span class="n">cefion</span><span class="o">.</span><span class="n">energies</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">En</span><span class="o">*</span><span class="n">beta</span><span class="p">)</span>
        

    <span class="n">dlogZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="p">),</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">d2logZ</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">dlogZ</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
    
    <span class="n">E</span> <span class="o">=</span> <span class="o">-</span><span class="n">dlogZ</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="n">dlogZ</span>
    <span class="n">Cv</span> <span class="o">=</span> <span class="n">beta</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d2logZ</span>
    
    <span class="k">return</span> <span class="n">Z</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Cv</span></div>

    
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">mikibox 0.2.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">mikibox.crysfipy.observables</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2022, Michal Stekiel.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>